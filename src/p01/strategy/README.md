## Паттерн Стратегия

> Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.
Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.

### Задача:

Нужно создать приложение - имитатор утиного пруда.

#### [step1](step1)
- **Решение**: Определили абстрактный класс `Duck`, на основе которого определим типы конкретных уток.

#### [step2](step2)
- **Проблема**: Решили добавить летающих уток.
- **Решение**: Добавим метод в родительский абстрактный класс

#### [step3](step3)

- **Проблема**: Добавили резиновых уток, но они не должны летать (как и крякать).
Поэтому переопределили методы `fly()` и `quack()`. Плюс, могут появиться другие утки, например деревянные.
- **Решение**: Перенести метод `fly()` в интерфейс `Flyable`, метод `quack()` в интерфейс `Quackable`.
И реализовать эти методы будут те, кто может выполнять данные функции через интерфейсы.

#### [step4](step4)
- **Проблема**: Реализация интерфейсов решает проблему частично и исключают повторного использования кода.
Плюс летающие утки могут летать по-разному.
Поведение изменяется в субклассах, а некоторые поведения присутствуют не во всех субклассах.
Если изменится аспект поведения, придется искать и изменять его во всех субклассах, где он определяется.
- **Решение**: Выделить переменные составляющие и инкапсулировать их.
Создадим 2 набора классов (независимых от `Duck`): для `fly()` и для `quack()` и вынесем за пределы класса `Duck` в
интерфейсы `FlyBehavior` и `Quackbehavior` соответствено.
Классы `FlyWIthWings` и `FlyNoWay` реализуют метод `fly()` интерфейса `FlyBehavior`.
Классы `Quack`, `Squeak` и `MuteQuack` реализуют метод `quack()` интерфейса `QuackBehavior`.

#### [step5](step5)
- **Задача**: Добавить возможность изменения поведения.
- **Решение**: Сделаем так, чтобы тип поведения задавался set-методом.